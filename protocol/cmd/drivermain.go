// Package cmd is used by drivers to implement the driver command.
package cmd

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"

	"github.com/bblfsh/sdk"
	"github.com/bblfsh/sdk/protocol"
	"github.com/bblfsh/sdk/uast"

	"github.com/bblfsh/sdk/uast/ann"
	"github.com/jessevdk/go-flags"
)

// DriverMain is the implementation of a driver main function. It is meant to be
// called from an autogenerated main.go in each driver.
func DriverMain(
	version, build string,
	toNoder uast.ToNoder,
	annotate *ann.Rule) {

	cmd := cmd{
		Version:   version,
		Build:     build,
		NativeBin: sdk.NativeBin,
		In:        os.Stdin,
		Out:       os.Stdout,
		Err:       os.Stderr,
		ToNoder:   toNoder,
		Annotate:  annotate,
	}

	if len(os.Args) == 1 {
		cmd := &serveCommand{cmd}
		if err := cmd.Execute(nil); err != nil {
			os.Exit(-1)
		}

		return
	}

	parser := flags.NewNamedParser(os.Args[0], flags.Default)
	parser.AddCommand("serve", "", "", &serveCommand{cmd: cmd})
	parser.AddCommand("parse-native", "", "", &parseNativeASTCommand{cmd: cmd})
	parser.AddCommand("parse-uast", "", "", &parseUASTCommand{cmd: cmd})

	if _, err := parser.Parse(); err != nil {
		if _, ok := err.(*flags.Error); ok {
			parser.WriteHelp(os.Stdout)
			fmt.Printf("\nBuild information\n  commit: %s\n  date:%s\n", version, build)
		}

		os.Exit(1)
	}
}

type cmd struct {
	Version   string
	Build     string
	In        io.Reader
	Out       io.Writer
	Err       io.Writer
	ToNoder   uast.ToNoder
	Annotate  *ann.Rule
	NativeBin string `long:"native-bin" description:"alternative path for the native binary"`
}

type serveCommand struct {
	cmd
}

func (c *serveCommand) Execute(args []string) error {
	client, err := protocol.ExecNative(c.NativeBin)
	if err != nil {
		return fmt.Errorf("error executing native: %s", err.Error())
	}

	server := &protocol.Server{
		In:       c.In,
		Out:      c.Out,
		Native:   client,
		ToNoder:  c.ToNoder,
		Annotate: c.Annotate,
	}

	if err := server.Start(); err != nil {
		_ = client.Close()
		return fmt.Errorf("error starting server: %s", err.Error())
	}

	if err := server.Wait(); err != nil {
		_ = client.Close()
		return fmt.Errorf("error waiting for server end: %s", err.Error())
	}

	if err := client.Close(); err != nil {
		return fmt.Errorf("error closing native: %s", err.Error())
	}

	return nil
}

type parseNativeASTCommand struct {
	cmd
	Args struct {
		File string
	} `positional-args:"yes"`
}

func (c *parseNativeASTCommand) Execute(args []string) error {
	f := c.Args.File

	client, err := protocol.ExecNative(sdk.NativeBin)
	if err != nil {
		return err
	}

	b, err := ioutil.ReadFile(f)
	if err != nil {
		return fmt.Errorf("error reading file %s: %s", f, err.Error())
	}

	req := &protocol.ParseNativeASTRequest{
		Content: string(b),
	}

	resp, err := client.ParseNativeAST(req)
	if err != nil {
		return fmt.Errorf("request failed: %q", err)
	}

	e := json.NewEncoder(os.Stdout)
	if err := e.Encode(resp); err != nil {
		return err
	}

	return nil
}

type parseUASTCommand struct {
	cmd
	Args struct {
		File string
	} `positional-args:"yes"`
}

func (c *parseUASTCommand) Execute(args []string) error {
	f := c.Args.File

	client, err := protocol.ExecNative(sdk.NativeBin)
	if err != nil {
		return err
	}

	b, err := ioutil.ReadFile(f)
	if err != nil {
		return fmt.Errorf("error reading file %s: %s", f, err.Error())
	}

	req := &protocol.ParseNativeASTRequest{
		Content: string(b),
	}

	resp, err := client.ParseNativeAST(req)
	if err != nil {
		return fmt.Errorf("request failed: %q", err)
	}

	uastResp := &protocol.ParseUASTResponse{}
	uastResp.Status = resp.Status
	uastResp.Errors = resp.Errors
	if err == nil && resp.Status != protocol.Fatal {
		n, err := c.ToNoder.ToNode(resp.AST)
		if err != nil {
			uastResp.Status = protocol.Fatal
			uastResp.Errors = append(uastResp.Errors, err.Error())
		} else {
			if err := c.Annotate.Apply(n); err != nil {
				uastResp.Status = protocol.Error
				uastResp.Errors = append(uastResp.Errors, err.Error())
			}

			uastResp.UAST = n
		}
	}

	e := json.NewEncoder(os.Stdout)
	if err := e.Encode(uastResp); err != nil {
		return err
	}

	return nil
}
